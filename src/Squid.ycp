/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Squid.ycp
 * Package:	Configuration of squid
 * Summary:	Squid settings, input and output functions
 * Authors:	Daniel Fiser <dfiser@suse.cz>
 *
 * $Id: Squid.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of squid.
 * Input and output routines.
 */

{

module "Squid";
textdomain "squid";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Service";
import "Summary";
import "FileUtils";
import "SuSEFirewall";

/**
 * Defines path used in SCR::Read/Write functions
 */
path squid_path = .etc.squid;

/**
 * Defines location of sysconfig file
 */
string sysconfig_file = "/etc/sysconfig/SuSEfirewall2.d/services/squid";

/**
 * Defines name of service which is used by firewall when it's openning ports.
 */
string firewall_service_name = "service:squid";
global string GetFirewallServiceName()
{
    return firewall_service_name;
}


/**
 * Data was modified?
 */
boolean modified = false;

/**
 * Is service enabled?
 */
boolean service_enabled_on_startup = false;


/**
 * Map of all configuration settings except consequential. Format:
 * $[ "parameter name" : [ list of options (rest of line) ]
 *    ...
 * ]
 */
map <string,any> settings = $[];

/**
 * List of http_ports. Format:
 * [ $["host" : "hostname",
 *     "port" : "3128",
 *     "transparent" : true],
 *     ...
 * ]
 */
list <map <string,any> > http_ports = [];

/**
 * List of acls. Format:
 * [ $[ "name" : "localhost",
 *      "type" : "src",
 *      "options" : [ non-empty list of options ]]
 *      ...
 * ]
 */
list <map <string,any> > acls = [];

/**
 * List of access control parameters. Format:
 * [ $["allow" : true,
 *     "acl" : ["acl1", "!acl2", ...] ],
 *     ...
 * ]
 */
list <map <string,any> > http_accesses = [];

/**
 * List of refresh patterns. Format:
 * [ $["regexp" : "^ftp:",
 *     "case_sensitive" : true,
 *     "min" : "12",
 *     "max" : "12",
 *     "percent" : "12"],
 *     ...
 * ]
 */
list <map <string,any> > refresh_patterns = [];


/**
 * Map of all available parameters with defalut values.
 * $[ "parameter_name" : [ list of default options ],
 *    ...
 *  ]
 */
map <string, list> parameters = $[
    "cache_dir" : ["ufs", "/var/cache/squid", "100", "16", "256"],
    "cache_mem" : ["8", "MB"],
    "cache_swap_low" : ["90"],
    "cache_swap_high" : ["95"],
    "maximum_object_size" : ["4096", "KB"],
    "minimum_object_size" : ["0", "KB"],
    "cache_replacement_policy" : ["lru"],
    "memory_replacement_policy" : ["lru"],

    "access_log" : ["/var/log/squid/access.log"],
    "cache_log" : ["/var/log/squid/cache.log"],
    "cache_store_log" : ["/var/log/squid/store.log"],
    "emulate_httpd_log" : ["off"],

    "connect_timeout" : ["2", "minutes"],
    "client_lifetime" : ["1", "days"],

    "error_directory" : ["/usr/share/squid/errors/English"],
    "cache_mgr" : ["webmaster"],
    "ftp_passive" : ["on"]
];



/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;



/*****************  HELP FUNCTIONS  ***************/
/**
 * Same as splitstring(), but returns only non-empty strings.
 */
list<string> split(string str, string delim)
{
    return filter(string value, splitstring(str, delim),
                {
                    //y2debug("Squid::split value: %1, size(value): %2",value, size(value));
                    return (size(value)>0);
                });
}

global integer NumACLs(integer id_item);
/**
 * Verify and repair list of ACLs if something's wrong.
 */
void verifyACLs()
{
    //verification of ACLs
    //There must not exist more ACLs with same name and different type
    integer i = 0;
    list<string> tested = [];
    list<integer> to_remove = [];
    integer ii = 0;
    foreach (map<string,any> value, acls,
        {
            if (!contains(tested, value["name"]:"")){
                if (NumACLs(i) > 0){
                    to_remove = [];
                    ii = 0;
                    foreach (map<string,any> val, acls,
                        {
                            if (val["name"]:"" == value["name"]:""
                                && val["type"]:"" != value["type"]:""){
                                to_remove = add(to_remove, ii);
                            }
                            ii = ii + 1;
                        });
                    //delete all ACLs which has not type same as value["type"]:"" -
                    // - it means type of first occurence of tested ACL
                    foreach (integer val, to_remove, { acls = remove(acls, val);});
                }
                tested = add(tested, value["name"]:"");
            }
            i = i + 1;
        });
}


string repairTimeoutPeriodUnits(string old)
{
    string ret = "seconds";
    if (old == "day"){
        ret = "days";
    }else if (old == "hour"){
        ret = "hours";
    }else if (old == "minute"){
        ret = "minutes";
    }else if (old == "second"){
        ret = "seconds";
    }else if (contains(["seconds", "minutes", "hours", "days"], old)){
        ret = old;
    }

    return ret;
}


/**
 * Function which sets permissions 'chmod 750' and 'chown squid:root'
 * to directory dir if exists.
 * If dir does not exist, function returns true;
 */
boolean setWritePremissionsToCacheDir(string dir)
{
    if (!FileUtils::IsDirectory(dir)){
        y2debug("Squid::checkWritePremissionsCacheDir() - '%1' is not directory", dir);
        return true;
    }

    if ((integer)SCR::Execute(.target.bash, "chown squid:root " + dir) != 0 ||
        (integer)SCR::Execute(.target.bash, "chmod 750 " + dir) != 0){
        return false;
        //return (Popup::ContinueCancel(sformat(_("Unable to set correct permissions to directory %1."), dir)));
    }

    return true;
}
/*****************  HELP FUNCTIONS END  ***********/





global void SetDefaultValues()
{
    http_ports = [$["host" : "",
                    "port" : "3128",
                    "transparent" : false]];
    acls = [
        $[ "name":"QUERY",
           "options":["cgi-bin \\?"],
           "type":"urlpath_regex" ],
        $[ "name":"apache",
           "options":[ "Server", "^Apache" ],
           "type":"rep_header" ],
        $[ "name":"all",
           "options":[ "0.0.0.0/0.0.0.0" ],
           "type":"src" ],
        $[ "name":"manager",
           "options":[ "cache_object" ],
           "type":"proto" ],
        $[ "name":"localhost",
           "options":[ "127.0.0.1/255.255.255.255" ],
           "type":"src" ],
        $[ "name":"to_localhost",
           "options":[ "127.0.0.0/8" ],
           "type":"dst" ],
        $[ "name":"SSL_ports",
           "options":[ "443" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "80" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "21" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "443" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "70" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "210" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "1025-65535" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "280" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "488" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "591" ],
           "type":"port" ],
        $[ "name":"Safe_ports",
           "options":[ "777" ],
           "type":"port" ],
        $[ "name":"CONNECT",
           "options":[ "CONNECT" ],
           "type":"method" ]
    ];
    http_accesses = [
        $[ "acl":[ "manager", "localhost" ],
           "allow":true ],
        $[ "acl":[ "manager" ],
           "allow":false ],
        $[ "acl":[ "!Safe_ports" ],
           "allow":false ],
        $[ "acl":[ "CONNECT", "!SSL_ports" ],
           "allow":false ],
        $[ "acl":[ "localhost" ],
           "allow":true ],
        $[ "acl":[ "all" ],
           "allow":false ]
    ];
    refresh_patterns = [
        $[ "case_sensitive":true,
           "max":"10080",
           "min":"1440",
           "percent":"20",
           "regexp":"^ftp:" ],
        $[ "case_sensitive":true,
           "max":"1440",
           "min":"1440",
           "percent":"0",
           "regexp":"^gopher:" ],
        $[ "case_sensitive":true,
           "max":"4320",
           "min":"0",
           "percent":"20",
           "regexp":"." ]
    ];
    settings = parameters;
    service_enabled_on_startup = false;
}



global boolean GetModified(){
    return modified;
}

global void SetModified()
{
    y2debug("Squid::SetModified() - Squid modified");
    modified = true;
}




/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = GetModified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if (AbortFunction != nil){
        return AbortFunction () == true;
    }
    return false;
}


/******* SERVICE *******/
global boolean IsServiceEnabled()
{
    return service_enabled_on_startup;
}

global void SetServiceEnabled(boolean enabled)
{
    SetModified();
    service_enabled_on_startup = enabled;
}
/******* SERVICE END  **/

/******* ACL *******/
global list<map<string,any> > GetACLs()
{
    return acls;
}

global map<string,any> GetACL(integer id_item)
{
    return acls[id_item]:$[];
}

global string GetACLType(integer id_item)
{
    return (acls[id_item]:$[])["type"]:"";
}

global string GetACLTypeByName(string acl_name)
{
    string ret = nil;
    foreach (map<string,any> value, acls,
        {
            if (value["name"]:"" == acl_name){
                ret = value["type"]:"";
                break;
            }
        });
    return ret;
}

global void AddACL(string name, string type, list<string> options)
{
    SetModified();
    acls = add(acls, $[ "name" : name,
                        "type" : type,
                        "options" : options]);
}

global void ModifyACL(integer id_item, string name, string type, list<string> options)
{
    if (id_item >= 0 && id_item < size(acls)){
        map<string, any> tmp = $[ "name" : name,
                                  "type" : type,
                                  "options" : options];
        if (tmp != acls[id_item]:$[]){
            SetModified();
            acls[id_item] = tmp;
        }
    }
}

global void DelACL(integer id_item)
{
    if (id_item >= 0 && id_item < size(acls)){
        SetModified();
        acls = remove(acls, id_item);
    }
}


/**
 * Returns number of occurences of ACL (definition lines) in config file.
 */
global integer NumACLs(integer id_item)
{
    string acl = (acls[id_item]:$[])["name"]:""; //get name of acl
    if (size(acl) == 0) return nil; //invalid id_item
    integer ret = 0;

    foreach (map<string, any> value, acls,
        {
            if (value["name"]:"" == acl)
                ret = ret + 1;
        });

    y2debug("Squid::NumACLs() - acl: %1, num: %2", acl, ret);

    return ret;
}

/**
 * Same as NumACLs but ACL is identified by name.
 */
global integer NumACLsByName(string name)
{
    integer ret = nil;
    integer i = 0;
    foreach (map<string,any> value, acls,
        {
            if (value["name"]:"" == name){
                break;
            }
            i = i + 1;
        });
    if (i < size(acls)){
        ret = NumACLs(i);
    }

    return ret;
}

/**
 * Returns list of options which use this ACL (identified by id_item).
 * It's necessary to run this function before deleting ACL to know if
 * any options are not affected.
 */
global list<string> ACLIsUsedBy(integer id_item)
{
    string acl = (GetACL(id_item))["name"]:"";
    if (size(acl) == 0) return nil; //invalid id_item

    list<string> params = [];
    list<string> ret = [];

    // options with format:
    //      option_name something ACL ACL ACL ...
    list<string> format1 = [
        "no_cache", "cache",
        "broken_vary_encoding",
        "follow_x_forwarded_for",
        //"http_access", -> cached in this module !!!
        "http_reply_access",
        "icp_access",
        "htcp_access",
        "miss_access",
        "ident_lookup_access",
        "log_access",
        "always_direct",
        "never_direct",
        "snmp_access",
        "broken_posts",
        "deny_info"
    ];
    // options with format:
    //      option_name something something ACL ACL ACL ...
    list<string> format2 = [
        "tcp_outgoing_tos",
        "tcp_outgoing_address",
        "reply_body_max_size",
        "header_access",
        "cache_peer_access",
        "access_log"
    ];

    list<string> available_options = SCR::Dir(squid_path);

    foreach (string value, (list<string>)merge(format1, format2),
        {
            if (contains(available_options, value)){
                foreach (string val, (list<string>)SCR::Read( add(squid_path, value)),
                    {
                        params = remove(split(val, " \t"), 0); // remove first param
                        if (contains(format2, value)){ // if it is format 2 remove also second param
                            if (size(params) > 1){
                                params = remove(params, 0);
                            }else{
                                break;
                            }
                        }

                        if (contains(params, acl) || contains(params, "!"+acl)){
                            ret = add(ret, value);
                            break;
                        }
                    });
            }
        });

    //http_access:
    foreach (map<string, any> value, http_accesses,
        {
            if (contains(value["acl"]:[], acl) || contains(value["acl"]:[], "!"+acl)){
                ret = add(ret, "http_access");
                break;
            }
        });

    y2debug("Squid::ACLIsUsedBy() - acl:%1, ret: %2", acl, ret);

    return ret;
}
/******* ACL END *******/

/******* HTTP_ACCESS ******/
global list<map<string,any> > GetHttpAccesses()
{
    return http_accesses;
}

global map<string,any> GetHttpAccess(integer id_item)
{
    return http_accesses[id_item]:$[];
}

global void AddHttpAccess(boolean allow, list<string> acl)
{
    SetModified();
    http_accesses = add(http_accesses, $["allow" : allow,
                                         "acl" : acl]);
}

global void ModifyHttpAccess(integer id_item, boolean allow, list<string> acl)
{
    if (id_item >= 0 && id_item < size(http_accesses)){
        map<string,any> tmp = $["allow" : allow,
                                "acl" : acl];

        if (tmp != http_accesses[id_item]:$[]){
            SetModified();
            http_accesses[id_item] = tmp;
        }
    }
}

global void DelHttpAccess(integer id_item)
{
    if (id_item >= 0 && id_item < size(http_accesses)){
        SetModified();
        http_accesses = remove(http_accesses, id_item);
    }
}

global void MoveHttpAccess(integer id_from, integer id_to)
{
    if (id_from >= 0 && id_from < size(http_accesses)
        && id_to >= 0 && id_to < size(http_accesses)
        && id_from != id_to){

        SetModified();
        map<string,any> tmp = http_accesses[id_from]:$[];
        http_accesses[id_from] = http_accesses[id_to]:$[];
        http_accesses[id_to] = tmp;
    }
}
/******* HTTP_ACCESS END ******/

/******* SETTINGS *****/
global map<string,any> GetSettings()
{
    return settings;
}

global list<string> GetSetting(string name)
{
    return settings[name]:[];
}

global void SetSetting(string name, list value)
{
    list tmp = value;

    if (tmp != settings[name]:[]){
        SetModified();
        settings[name] = value;
    }
}

/******* SETTINGS END *****/

/**** REFRESH PATTERN ****/
global list <map<string,any> > GetRefreshPatterns()
{
    return refresh_patterns;
}

global map<string,any> GetRefreshPattern(integer id_item)
{
    return refresh_patterns[id_item]:$[];
}

global void AddRefreshPattern(string regexp, string min, string percent, string max, boolean case_sensitive)
{
    SetModified();
    refresh_patterns = add(refresh_patterns, $[ "regexp" : regexp,
                                                "min" : min,
                                                "percent" : percent,
                                                "max" : max,
                                                "case_sensitive" : case_sensitive]);
}

global void ModifyRefreshPattern(integer id_item, string regexp, string min, string percent, string max, boolean case_sensitive)
{
    if (id_item >= 0 && id_item < size(refresh_patterns)){
        map<string,any> tmp = $[ "regexp" : regexp,
                                 "min" : min,
                                 "percent" : percent,
                                 "max" : max,
                                 "case_sensitive" : case_sensitive];
        if (tmp != refresh_patterns[id_item]:$[]){
            SetModified();
            refresh_patterns[id_item] = tmp;
        }
    }
}

global void DelRefreshPattern(integer id_item)
{
    if (id_item >= 0 && id_item < size(refresh_patterns)){
        SetModified();
        refresh_patterns = remove(refresh_patterns, id_item);
    }
}

global void MoveRefreshPattern(integer id_from, integer id_to)
{
    if (id_from >= 0 && id_from < size(refresh_patterns)
        && id_to >= 0 && id_to < size(refresh_patterns)
        && id_from != id_to){

        SetModified();
        map<string,any> tmp = refresh_patterns[id_from]:$[];
        refresh_patterns[id_from] = refresh_patterns[id_to]:$[];
        refresh_patterns[id_to] = tmp;
    }
}
/**** REFRESH PATTERN END ****/

/**** HTTP PORT *****/
/**
 * Returns only list of configured ports (no hosts and so on)
 */
global list<string> GetHttpPortsOnly()
{
    list<string> ret = [];
    foreach (map<string, any> value, http_ports,
        {
            if (size(value["port"]:"") > 0)
                ret = add(ret, value["port"]:"");
        });
    return ret;
}

global list <map<string, any> > GetHttpPorts()
{
    return http_ports;
}

global map<string, any > GetHttpPort(integer id_item)
{
    return http_ports[id_item]:$[];
}

global void AddHttpPort(string host, string port, boolean transparent)
{
    SetModified();
    http_ports = add(http_ports, $["host" : host,
                                   "port" : port,
                                   "transparent" : transparent]);
}

global void ModifyHttpPort(integer id_item, string host, string port, boolean transparent)
{
    if (id_item >= 0 && id_item < size(http_ports)){
        map<string,any> tmp = $["host" : host,
                                "port" : port,
                                "transparent" : transparent];
        if (tmp != http_ports[id_item]:$[]){
            SetModified();
            http_ports[id_item] = tmp;
        }
    }
}

global void DelHttpPort(integer id_item)
{
    if (id_item >= 0 && id_item < size(http_ports)){
        SetModified();
        http_ports = remove(http_ports, id_item);
    }
}
/**** HTTP PORT END *****/



/********************  READ  **********************/


/**
 * Read setting of parameter http_port.
 *      http_port [hostname:]port [transparent]
 *
 * return true on success
 */
boolean readHttpPorts()
{
    boolean ok = true;
    list tmp = [];
    list tmp2 = [];
    map <string,any> tmp_http_port = $[];

    http_ports = [];
    foreach (string value, (list<string>)SCR::Read(add(squid_path,"http_port")),
        {
            tmp_http_port = $[];
            tmp = [];
            tmp2 = [];

            tmp = split(value," \t");

            //can parse only 'http_port hostname:port [transparent]'
            if (size(tmp) < 1 || size(tmp) > 2){
                ok = false;
                return false;
            }

            // hostname and port
            tmp2 = split(tmp[0]:"",":");
            y2debug("readHttpPorts - tmp2: %1",tmp2);
            if (size(tmp2) == 1){
                tmp_http_port["host"] = "";
                tmp_http_port["port"] = tmp2[0]:"";
            }else{
                tmp_http_port["host"] = (string)tmp2[0]:"";
                tmp_http_port["port"] = tmp2[1]:"";
            }

            //transparent option
            if (size(tmp) == 2 && tmp[1]:"" == "transparent")
                tmp_http_port["transparent"] = true;

            http_ports = add(http_ports, tmp_http_port);
        });

    return ok;
}

/**
 * Read setting of parameter http_access.
 *      http_access allow acl1 !acl2 ...
 *
 * return true on success
 */
boolean readHttpAccesses()
{
    boolean ok = true;
    list tmp = [];
    map <string,any> tmp_http_access = $[];

    http_accesses = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path,"http_access")),
        {
            tmp_http_access = $[];

            tmp = split(value, " \t");

            if (tmp[0]:"" != "allow" && tmp[0]:"" != "deny"){
                ok = false;
                return false;
            }

            tmp_http_access["allow"] = (tmp[0]:"" == "allow" ? true : false);
            tmp_http_access["acl"] = remove(tmp, 0);

            http_accesses = add(http_accesses, tmp_http_access);
        });

    return ok;
}

/**
 * Read setting of parameter refresh_pattern.
 *      refresh_pattern [-i] regexp min percent max [options (ignored)]
 *
 * return true on success
 */
boolean readRefreshPatterns()
{
    boolean ok = true;
    list tmp = [];
    map <string,any> tmp_refresh_pattern = $[];

    refresh_patterns = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path, "refresh_pattern")),
        {
            tmp_refresh_pattern = $[];

            tmp = split(value, " \t");

            //case-insesitive
            if (tmp[0]:"" == "-i"){
                tmp_refresh_pattern["case_sensitive"] = false;
                tmp = remove(tmp, 0);
            }else{
                tmp_refresh_pattern["case_sensitive"] = true;
            }

            if (size(tmp) < 4){
                ok = false;
                return false;
            }

            tmp_refresh_pattern["regexp"] = tmp[0]:"";
            tmp_refresh_pattern["min"] = tmp[1]:"";
            tmp_refresh_pattern["percent"] = deletechars(tmp[2]:"","%");
            tmp_refresh_pattern["max"] = tmp[3]:"";

            refresh_patterns = add(refresh_patterns, tmp_refresh_pattern);
        });

    return ok;
}

/**
 * Read setting of parameter acl.
 *      acl aclname acltype string1 string2 ...
 *
 * return true on success
 */
boolean readACLs()
{
    boolean ok = true;
    list tmp = [];
    map <string, any> tmp_acl = $[];

    //list of types which contains regular expression
    list<string> regexps = [
        "srcdom_regex",
        "dstdom_regex",
        "url_regex",
        "urlpath_regex",
        "browser"
    ];

    acls = [];
    foreach (string value, (list<string>)SCR::Read( add(squid_path, "acl")),
        {
            tmp_acl = $[];

            tmp = split(value, " \t");

            if (size(tmp) < 3){
                ok = false;
                return false;
            }

            tmp_acl["name"] = tmp[0]:"";
            tmp_acl["type"] = tmp[1]:"";
            tmp_acl["options"] = remove(remove(tmp,0),0);

            // Special settings:
            // concat list of regular expressions into one option
            if (contains(regexps, tmp_acl["type"]:"")){
                if ((tmp_acl["options"]:[])[0]:"" == "-i"){
                    tmp_acl["options"] = ["-i", mergestring((list<string>)remove(tmp_acl["options"]:[], 0), " ")];
                }else{
                    tmp_acl["options"] = [mergestring(tmp_acl["options"]:[], " ")];
                }
            }else
            //format: acl aclname header_name [-i] list of regexps
            if(tmp_acl["type"]:"" == "req_header" || tmp_acl["type"]:"" == "rep_header"){
                if ((tmp_acl["options"]:[])[1]:"" == "-i"){
                    tmp_acl["options"] = [(tmp_acl["options"]:[])[0]:"",
                                          "-i",
                                          mergestring((list<string>)remove(remove(tmp_acl["options"]:[], 0), 0), " ")];
                }else{
                    tmp_acl["options"] = [(tmp_acl["options"]:[])[0]:"",
                                          mergestring((list<string>)remove(tmp_acl["options"]:[], 0), " ")];
                }
            }

            acls = add(acls, tmp_acl);
        });

    verifyACLs();

    return ok;
}

/**
 * Read rest of setting.
 * return true on success
 */
boolean readRestSetting()
{
    boolean ok = true;
    list tmp = [];

    settings = $[];
    foreach (string key, list value, parameters,
        {
            tmp = (list <string>)SCR::Read( add(squid_path, key));
            tmp = split(tmp[0]:"", " \t");

            if (size(tmp) > 0){
                settings[key] = tmp;
            }else{
                settings[key] = value;
            }

        });

    //special modification
    settings["cache_replacement_policy"] = [mergestring(settings["cache_replacement_policy"]:[]," ")];
    settings["memory_replacement_policy"] = [mergestring(settings["memory_replacement_policy"]:[]," ")];
    settings["connect_timeout"] = [ (settings["connect_timeout"]:[])[0]:"",
                                    repairTimeoutPeriodUnits((settings["connect_timeout"]:[])[1]:"") ];
    settings["client_lifetime"] = [ (settings["client_lifetime"]:[])[0]:"",
                                    repairTimeoutPeriodUnits((settings["client_lifetime"]:[])[1]:"") ];

    return ok;
}

boolean readServiceStatus()
{
    service_enabled_on_startup = Service::Enabled("squid");
    return true;
}

boolean readAllSettings()
{
    boolean ok = true;

    if (!readHttpPorts()) ok = false;
    Progress::NextStage();

    if (!readRefreshPatterns()) ok = false;
    Progress::NextStage();

    if (!readACLs()) ok = false;
    Progress::NextStage();

    if (!readHttpAccesses()) ok = false;
    Progress::NextStage();

    if (!readRestSetting()) ok = false;
    Progress::NextStage();

    return ok;
}

/**
 * Read all squid settings
 * @return true on success
 */
global boolean Read() {
    boolean ok = true;

    Progress::New(_("Initializing squid Configuration"),
                  " ",
                  7,
                  [_("Read HTTP Ports from config file."),
                   _("Read Refresh Patterns from config file."),
                   _("Read ACL Groups from config file."),
                   _("Read Access Control table from config file."),
                   _("Read the rest settings."),
                   _("Read service status."),
                   _("Read firewall settings.")],
                  [_("Reading HTTP Ports ..."),
                   _("Reading Refresh Patterns ..."),
                   _("Reading ACL Groups ..."),
                   _("Reading Access Control table ..."),
                   _("Reading the rest settings ..."),
                   _("Reading service status ..."),
                   _("Reading firewall settings ...")],
                  "");

    if(Abort()) return false;
    Progress::NextStage();

    if (!readAllSettings()){
        ok = false;
        Report::Error(_("Cannot read configuration file."));
    }

    if (!readServiceStatus()){
        ok = false;
        Report::Error(_("Cannot read service status."));
    }
    Progress::NextStage();

    Progress::set(false);
    if (!SuSEFirewall::Read()){
        ok = false;
        Report::Error(_("Cannot read firewall settings."));
    }
    Progress::set(true);
    Progress::NextStage();

    y2milestone("================ Setting ======================");
    y2debug("Squid::Read - http_ports: %1",http_ports);
    y2debug("Squid::Read - http_accesses: %1", http_accesses);
    y2debug("Squid::Read - acls: %1", acls);
    y2debug("Squid::Read - refresh_patterns: %1", refresh_patterns);
    y2debug("Squid::Read - settings: %1", settings);
    y2debug("Squid::Read - enabled: %1", service_enabled_on_startup);
    y2milestone("================ Setting END ==================");

    return ok;
}
/********************  READ END  ******************/



/********************  WRITE  *********************/


boolean writeHttpPorts()
{
    boolean ok = true;
    list<string> scr = [];
    string tmp = "";

    foreach (map<string,any> value, http_ports,
        {
            tmp = value["host"]:"";
            if (size(value["host"]:"") > 0) tmp = tmp + ":";
            tmp = tmp + value["port"]:"";
            if (value["transparent"]:false) tmp = tmp + " transparent";

            scr = add(scr, tmp);
        });

    y2debug("Squid::Write - http_port: %1", scr);
    if (!SCR::Write(add(squid_path, "http_port"), scr))
        ok = false;

    return ok;
}

boolean writeACLs()
{
    boolean ok = true;
    list<string> scr = [];
    string tmp = "";

    foreach (map<string, any> value, acls,
        {
            tmp = value["name"]:"";
            tmp = tmp + " " + value["type"]:"";
            tmp = tmp + " " + mergestring(value["options"]:[], " ");
            scr = add(scr, tmp);
        });

    y2debug("Squid::Write - acl: %1", scr);
    if (!SCR::Write(add(squid_path, "acl"), scr))
        ok = false;

    return ok;
}


boolean writeHttpAccesses()
{
    boolean ok = true;
    list<string> scr = [];
    string tmp = "";

    foreach (map<string,any> value, http_accesses,
        {
            if (value["allow"]:true){
                tmp = "allow";
            }else{
                tmp = "deny";
            }
            tmp = tmp + " " + mergestring(value["acl"]:[], " ");
            scr = add(scr, tmp);
        });

    y2debug("Squid::Write - http_access: %1", scr);
    if (!SCR::Write(add(squid_path, "http_access"), scr))
        ok = false;

    return ok;
}


boolean writeRefreshPatterns()
{
    boolean ok = true;
    list<string> scr = [];
    string tmp = "";

    foreach (map<string,any> value, refresh_patterns,
        {
            tmp = "";
            if (!value["case_sensitive"]:false) tmp = "-i ";
            tmp = tmp + value["regexp"]:"";
            tmp = tmp + " " + value["min"]:"";
            tmp = tmp + " " + value["percent"]:"";
            tmp = tmp + " " + value["max"]:"";
            scr = add(scr, tmp);
        });

    y2debug("Squid::Write - refresh_pattern: %1", scr);
    if (!SCR::Write(add(squid_path, "refresh_pattern"), scr))
        ok = false;

    return ok;
}


boolean writeRestSetting()
{
    boolean ok = true;
    string tmp = "";
    list<string> setting = nil;

    foreach (string key, list value, parameters,
        {
            tmp = mergestring(settings[key]:[], " ");
            if (size(tmp) > 0){
                y2debug("Squid::Write - %1: %2", key, tmp);
                if (!SCR::Write(add(squid_path, key), [tmp])){
                    y2error("Squid::Write - cannot write %1 setting", key);
                    ok = false;
                }
            }else{
                y2debug("Squid::Write - %1: %2", key, nil);
                if (!SCR::Write(add(squid_path, key), nil)){
                    y2error("Squid::Write - cannot write %1 setting", key);
                    ok = false;
                }
            }
        });

    return ok;
}

boolean writePermissions()
{
    string cache_dir = (settings["cache_dir"]:[])[1]:"";
    boolean ok = true;

    if (!setWritePremissionsToCacheDir(cache_dir))
        ok = false;
    return ok;
}

boolean writeAllSettings()
{
    boolean ok = true;

    if (!writePermissions()) ok = false;

    if (!GetModified()){
        y2debug("Squid::Write - no setting to write, because nothing's changed");
        return ok;
    }

    y2milestone("Squid::writeAllSettings started");

    if (!writeHttpPorts()){
        y2error("Squid::writeAllSettings - writeHttpPorts failed");
        ok = false;
    }
    if (!writeACLs()){
        y2error("Squid::writeAllSettings - writeACLs failed");
        ok = false;
    }
    if (!writeHttpAccesses()){
        y2error("Squid::writeAllSettings - writeHttpAccesses failed");
        ok = false;
    }
    if (!writeRefreshPatterns()){
        y2error("Squid::writeAllSettings - writeRefreshPatterns failed");
        ok = false;
    }
    if (!writeRestSetting()){
        y2error("Squid::writeAllSettings - writeRestSetting failed");
        ok = false;
    }

    if (ok){
        if (!SCR::Write(squid_path, nil)){
            y2error("Squid::Write - cannot write settings: `Write(%1, nil)", squid_path);
            ok = false;
        }
    }

    y2milestone("Squid::writeAllSettings finished");

    return ok;
}

boolean writeFirewallSettings()
{
    boolean ok = true;

    if (!GetModified()){
        y2debug("Squid::writeFirewallSettings - no setting to write, because nothing's changed");
        return ok;
    }

    if (!SCR::RegisterAgent (.firewall_service_definition, `ag_ini(`SysConfigFile(sysconfig_file)))){
        ok = false;
        y2error("Unable to register sysconfig agent for %1", sysconfig_file);
    }
    if (!SCR::Write(.firewall_service_definition.TCP, mergestring(GetHttpPortsOnly(), " ")) ||
        !SCR::Write(.firewall_service_definition, nil)){
        ok = false;
        y2error("Unable to write settings into sysconfig file %1", sysconfig_file);
    }
    if (!SCR::UnregisterAgent (.firewall_service_definition)){
        ok = false;
        y2error("Unable to unregister sysconfig agent for %1", sysconfig_file);
    }
    // write /etc/sysconfig/SuSEFirewall2.d/services/squid file:
    /*
    string service_squid_file =
        "## Name: Squid Service\n" +
        "## Description: Opens ports for Squid\n" +
        "TCP=\"" + mergestring(GetHttpPortsOnly(), " ") +"\"\n";
    if (!SCR::Write(.target.string, "/etc/sysconfig/SuSEfirewall2.d/services/squid", service_squid_file)){
        y2error("Squid::writeFirewallSettings - failed to write into /etc/sysconfig/SuSEfirewall2.d/services/squid file.");
        ok = false;
    }
    */

    // write firewall settings
    SuSEFirewall::SetModified();
    Progress::set(false);
    if (!SuSEFirewall::Write()){
        y2error("Squid::writeFirewallSettings - SuSEFirewall::Write failed");
        ok = false;
    }
    Progress::set(true);

    return ok;
}

/**
 * Returns true if Squid service is running.
 */
global boolean IsServiceRunning()
{
    return (Service::Status("squid") == 0);
}

/**
 * Start Squid service if not running otherwise reload.
 * Returns true if squid was successfuly started
 */
global boolean StartService()
{
    boolean ok = true;
    //verify config file
    //if ((integer)SCR::Execute(.target.bash, "squid -k parse") != 0){
    //    y2error("Squid::Write - startService - 'squid -k parse' failed");
    //    return false;
    //}

    if (!IsServiceRunning()){
        if (!Service::Start("squid")){
            ok = false;
            Report::Error(Message::CannotStartService("squid"));
        }
    }else{
        if (!Service::Restart("squid")){
            ok = false;
            Report::Error(Message::CannotRestartService("squid"));
        }
    }

    return ok;
}

/**
 * Stop Squid service.
 * Returns true if squid was successfuly stopped
 */
global boolean StopService()
{
    boolean ok = true;

    if (IsServiceRunning()){
        if (!Service::Stop("squid")){
            ok = false;
            Report::Error(Message::CannotStopService("squid"));
        }
    }
    return ok;
}

global boolean EnableService()
{
    return Service::Enable("squid");
}

global boolean DisableService()
{
    return Service::Disable("squid");
}

/**
 * Write all squid settings
 * @return true on success
 */
global boolean Write() {
    boolean ok = true;

    // We do not set help text here, because it was set outside
    Progress::New(_("Saving Squid Configuration"),
                  " ",
                  3,
                  [
                    /* Progress stage 1/2 */
                    _("Write the settings"),
                    /* Progress stage 1/2 */
                    _("Write firewall settings"),
                    /* Progress stage 2/2 */
                    _("Start Service")
                  ],
                  [
                    /* Progress step 1/2 */
                    _("Writing the settings..."),
                    /* Progress step 1/2 */
                    _("Writing firewall settings..."),
                    /* Progress step 2/2 */
                    _("Starting Service..."),
                    /* Progress finished */
                    _("Finished")
                  ],
                  ""
                 );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    if(!writeAllSettings()){
        Report::Error (_("Cannot write settings."));
        ok = false;
    }

    //firewall
    if (!writeFirewallSettings()){
        Report::Error(_("Cannot write firewall settings."));
        ok = false;
    }
    Progress::NextStage();

    //enabling / disabling service
    if (service_enabled_on_startup == true) EnableService();
    if (service_enabled_on_startup == false) DisableService();

    // start Service
    if(Abort()) return false;
    Progress::NextStage ();
    if (!write_only){
        if(!StartService()) ok = false;
    }

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return ok;
}
/********************  WRITE END  *****************/



/*******************  AUTOYAST  *******************/

/**
 * Get all squid settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map sett) {
    if (sett == $[] || sett == nil){
        SetDefaultValues();
        SetModified();
        return true;
    }
    if (!haskey(sett, "http_ports") ||
        !haskey(sett, "acls") ||
        !haskey(sett, "http_accesses") ||
        !haskey(sett, "refresh_patterns") ||
        !haskey(sett, "settings") ||
        !haskey(sett, "service_enabled_on_startup")){

        return false;
    }

    http_ports = (list<map<string,any> >)sett["http_ports"]:[];
    acls = (list<map<string,any> >)sett["acls"]:[];
    http_accesses = (list<map<string,any> >)sett["http_accesses"]:[];
    refresh_patterns = (list<map<string,any> >)sett["refresh_patterns"]:[];
    settings = (map<string,any>)sett["settings"]:$[];
    service_enabled_on_startup = (boolean)sett["service_enabled_on_startup"]:false;
    SetModified();

    return true;
}

/**
 * Dump the squid settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[ "http_ports" : http_ports,
              "acls" : acls,
              "http_accesses" : http_accesses,
              "refresh_patterns" : refresh_patterns,
              "settings" : settings,
              "service_enabled_on_startup" : service_enabled_on_startup ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    string summary = "";
    string tmp = "";
    if (!GetModified()){
        summary = Summary::NotConfigured();
    }else{
        // Header
        summary = Summary::AddHeader("", _("Squid Cache Proxy"));

        // Start daemon
        summary = Summary::AddLine(summary, _("Start daemon: ") +
                "<i>" + (service_enabled_on_startup ? _("When booting") : _("Manually")) + "</i>");

        // Http Ports
        summary = Summary::AddLine(summary, _("Configured ports:"));
        if (size(http_ports) > 0){
            summary = Summary::OpenList(summary);
            foreach (map<string,any> value, http_ports,
                {
                    tmp = "<i>";
                    if (size(value["host"]:"") > 0) tmp = tmp + value["host"]:"" + ":";
                    tmp = tmp + value["port"]:"" + (value["transparent"]:false ? _(" (transparent)") : "");
                    tmp = tmp + "</i>";
                    summary = Summary::AddListItem(summary, tmp);
                });
            summary = Summary::CloseList(summary);
        }

        //Cache directory
        summary = Summary::AddLine(summary, _("Cache directory: ") + "<i>" + (settings["cache_dir"]:[])[1]:"" + "</i>");
    }
    return [ summary, [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 *
global list Overview() {
    return [];
}
*/

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":["squid"], "remove":[] ];
}
/*******************  AUTOYAST END  ***************/

/* EOF */
}
/* vim: set sw=4 ts=4 et ft=ycp : */
